<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="htmx-config" content='{"globalViewTransitions": true}'>
	<title>{{ site_title }}</title>

	<meta name="author" content="iLude">
	<meta name="description" content="{{ site_title }}">

	<meta property="og:title" content="{{ site_title }}">
	<meta property="og:type" content="{{ site_title }}">
	<meta property="og:url" content="">
	<meta property="og:image" content="">
	<meta property="og:image:alt" content="{{ site_title }}">

	<script defer src="https://unpkg.com/htmx.org@2.0.6/dist/htmx.min.js"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/htmx-ext-preload@2.0.2/dist/preload.js"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/htmx-ext-head-support@2.0.2/dist/head-support.js"></script>
	<script defer src="https://cdn.jsdelivr.net/npm/htmx-ext-loading-states@2.0.2/dist/loading-states.js"></script>
	<!-- Dev: Alpine.js was removed from runtime; re-add intentionally if needed for development -->

		<!-- Use Font Awesome CSS only (no JS injection) to keep icons as <i> elements which CSS can rotate -->
		<link href="https://use.fontawesome.com/releases/v5.15.3/css/all.css" rel="stylesheet">
	{% assets "css_all" %}
	<link rel="stylesheet" href="{{ ASSET_URL }}">
	{% endassets %}
</head>
<body hx-boost="true" hx-ext="head-support,loading-states">
	{% include('flash_message.html') %}
	<div id="bookmarkBar">
		{% with bookmarks = layout.bookmark_bar %}
			{% include 'bookmark_bar.html' ignore missing with context %}
		{% endwith %}
  </div>
	<div class="container">
		<div class="row header">
			<div class="column">
				<div class="row">
					{% for header in layout.headers %}
					<a href="{{header.link}}" target="_blank">{{header.name}}</a>
					{% endfor %}
				</div>
				<div class="row tab-bar">
					{% for tab in layout.tabs %}
						<a href="/tab/{{tab.name}}"
						   hx-get="/tab/{{tab.name}}"
						   hx-target="#main-content"
						   hx-swap="innerHTML transition:true"
						   hx-push-url="true"
						   data-loading-class="tab-loading"
						   data-loading-class-remove="tab-loading"
						   data-index="{{ loop.index }}"
						   data-current="{{ tab.name == tab_name }}">{{tab.name}}</a>
					{% endfor %}
				</div>
			</div>
			<div class="column">
				<div class="logo"><!-- Placeholder for the logo --></div>
			</div>
		</div>
		<div id="main-content">
			{% for row in layout.tab(tab_name).rows:  %}
				{% with row=row %}
					{% include "row.html" %}
				{% endwith %}
			{% endfor %}
		</div>
		<footer>
			<div>
				<a href="https://github.com/traefikturkey/onboard" target="_blank">OnBoard</a>
				is a
				<a href="https://github.com/traefikturkey" target="_blank">TraefikTurkey Project</a>
				&copy; {{ today_date.year }}
			</div>
		</footer>
	</div>
</body>
<script>
// Dev-only helper: detect and clean up lingering loading indicators which
// can cause continuous CSS animations and repaints. Runs only on localhost.
;(function(){
	try {
		const host = (location && location.hostname) || '';
		if (!(host === 'localhost' || host === '127.0.0.1')) return;

		// Periodically log counts for quick diagnosis in DevTools
		setInterval(() => {
			const widgetLoading = document.querySelectorAll('.widget-loading').length;
			const overlays = document.querySelectorAll('.loading-overlay.loading').length;
			if (widgetLoading || overlays) {
				console.warn('DEBUG: widget-loading:', widgetLoading, 'loading-overlay.loading:', overlays);
			}
		}, 2000);

		// Remove any .widget-loading classes that persist longer than 8s as a
		// defensive measure during development so stray animations don't burn CPU.
		const CLEANUP_MS = 8000;
		const seen = new Map();

		setInterval(() => {
			document.querySelectorAll('.widget-loading').forEach(el => {
				const now = Date.now();
				if (!seen.has(el)) seen.set(el, now);
				const firstSeen = seen.get(el) || now;
				if (now - firstSeen > CLEANUP_MS) {
					console.warn('DEBUG: removing stale .widget-loading on', el);
					el.classList.remove('widget-loading');
					el.removeAttribute('aria-busy');
					el.removeAttribute('aria-live');
					seen.delete(el);
				}
			});
			// Cleanup map entries for elements that no longer have the class
			for (const [el] of Array.from(seen.entries())) {
				if (!el.classList || !el.classList.contains('widget-loading')) seen.delete(el);
			}
		}, 1000);
	} catch (err) {
		console.error('DEBUG helper failed', err);
	}
})();
</script>
<script>
// Enhance folders with multi-column layout based on their data attributes
(function(){
	function markMultiColumnFolders(){
		const targets = document.querySelectorAll('#bookmarkBar a.bookmark-folder[data-multi-column]');
		targets.forEach(target => {
			const columnCount = parseInt(target.getAttribute('data-multi-column'), 10);
			if(columnCount && columnCount > 1) {
				const li = target.closest('li');
				if(li) {
					li.classList.add('multi-column-folder');
					li.style.setProperty('--column-count', columnCount);
				}
			}
		});
	}
	if(document.readyState === 'loading'){
		document.addEventListener('DOMContentLoaded', markMultiColumnFolders);
	} else {
		markMultiColumnFolders();
	}
})();
</script>
<script>
// Lightweight delegated widget controller to replace small Alpine usage.
(function(){
	// Toggle summary display when a list item or its toolbar icon is clicked.
	document.addEventListener('click', function(e){
		// Stop propagation for links that were marked to stop it
		if (e.target.closest('[data-stop-propagation]')) {
			e.stopPropagation();
			return;
		}

		var toggle = e.target.closest('[data-toggle-id]');
		if (!toggle) return;
		var id = toggle.getAttribute('data-toggle-id');
		var list = toggle.closest('[data-widget]');
		if (!list) return;

		// close any open summary
		var openId = list.getAttribute('data-open-id') || '';
		if (openId && openId !== id) {
			var prevSummary = list.querySelector('[data-summary-for="' + openId + '"]');
			var prevIcon = list.querySelector('[data-toggle-icon-for="' + openId + '"]');
			if (prevSummary) prevSummary.setAttribute('hidden','');
			if (prevIcon) {
				// ensure previous icon is reset to collapsed state
				prevIcon.classList.remove('fa-chevron-right');
				prevIcon.classList.add('fa-chevron-down');
				prevIcon.setAttribute('aria-expanded','false');
			}
		}

		var summary = list.querySelector('[data-summary-for="' + id + '"]');
		var icon = list.querySelector('[data-toggle-icon-for="' + id + '"]');
		var isHidden = summary && summary.hasAttribute('hidden');
			if (isHidden) {
				summary.removeAttribute('hidden');
				if (icon) {
					icon.classList.remove('fa-chevron-down');
					icon.classList.add('fa-chevron-right');
					icon.setAttribute('aria-expanded','true');
				}
				list.setAttribute('data-open-id', id);
			} else {
				if (summary) summary.setAttribute('hidden','');
				if (icon) {
					icon.classList.remove('fa-chevron-right');
					icon.classList.add('fa-chevron-down');
					icon.setAttribute('aria-expanded','false');
				}
				list.setAttribute('data-open-id', '');
			}
	});

	// Also close summary when clicking outside the list
	document.addEventListener('click', function(e){
		// clicking anywhere else will be handled by other handlers; ignore
	});
})();
</script>
<script>
// Double-click handler for opening all links in a bookmark folder.
(function(){
	function collectLinksRecursive(li){
		const results = [];
		if(!li) return results;
		const ul = li.querySelector(':scope > ul');
		if(!ul) return results;
		// Iterate only direct child list items to preserve folder boundaries
		ul.querySelectorAll(':scope > li').forEach(childLi => {
			const folder = childLi.querySelector(':scope > a.bookmark-folder[data-bookmark-folder]');
			if(folder){
				results.push(...collectLinksRecursive(childLi));
			} else {
				const link = childLi.querySelector(':scope > a[href]:not(.bookmark-folder)');
				if(link) results.push(link);
			}
		});
		return results;
	}

	document.addEventListener('dblclick', function(e){
		const folderAnchor = e.target.closest('a.bookmark-folder[data-bookmark-folder]');
		if(!folderAnchor) return;
		e.preventDefault();
		e.stopPropagation();
		const li = folderAnchor.closest('li');
		if(!li) return;
		const links = collectLinksRecursive(li);
    if (!links.length) return;
		const confirmMsg = `Do you want to open all these links in new tabs? (Count: ${links.length})`;
		if(!window.confirm(confirmMsg)) return;
		// Attempt to open each link. Browsers may block some if too many; first should always succeed.

    for (const a of links){
      try {
        window.open(a.href, '_blank', 'noopener,noreferrer');
      } catch (error) {
        console.error('Error opening link:', { href: a.href, title: a.innerText, error });
      }
    };
	});
})();
</script>
</html>
